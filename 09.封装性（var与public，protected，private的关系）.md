# 9.封装性（var与public，protected，private的关系）

封装性是面象对象编程中的三大特性之一，封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义：

1. 把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。
2. 信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界〔或者说形成一道屏障〕，只保留有限的对外接口使之与外部发生联系。

封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据（属性），从而有效的避免了外部错误对它的"交叉感染"，使软件错误能够局部化，大大减少查错和排错的难度。

用个实例来说明吧， 假如某个人的对象中有年龄和工资等属性，像这样个人隐私的属性是不想让其它人随意就能获得到的，如果你不使用封装，那么别人想知道就能得到，但是如果你封装上之后别人就没有办法获得封装的属性， 除非你自己把它说出去，否则别人没有办法得到。

再比如说，个人电脑都有一个密码，不想让其它人随意的登陆，在你电脑里面拷贝和粘贴。还有就是像人这个对象， 身高和年龄的属性， 只能是自己来增涨，不可以让别人随意的赋值等等。

使用private这个关键字来对属性和方法进行封装：

原来的成员：

```php
var $name;  // 声明人的姓名
var $sex;   // 声明人的性别
var $age;   // 声明人的年龄
function run(){……}
```

改成封装的形式：

```php
private $name;  // 把人的姓名使用private关键字进行封装
private $sex;   // 把人的性别使用private关键字进行封装
private $age;   // 把人的年龄使用private关键字进行封装
private function run(){……} // 把人的走路方法使用private关键字进行封装
```

**注意：只要是成员属性前面有其它的关键字就要去掉原有的关键字”var”。**

通过private就可以把人的成员（成员属性和成员方法）封装上了。封装上的成员就不能被类外面直接访问了，只有对象内部自己可以访问，下面的代码会产生错误：

```php
<?php
class Person {
    // 下面是人的成员属性
    private $name;      // 人的名子，被private封装上了
    private $sex;       // 人的性别, 被private封装上了
    private $age;       // 人的年龄, 被private封装上了
 
    // 这个人可以说话的方法
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
 
    // 这个人可以走路的方法, 被private封装上了
    private function run() {
        echo "这个人在走路";
    }
}
 
// 实例化一个人的实例对象
$p1 = new Person();
 
// 试图去给私有的属性赋值， 结果会发生错误
$p1->name = "张三";
$p1->sex = "男";
$p1->age = 20;
 
// 试图去打印私有的属性， 结果会发生错误
echo $p1->name;
echo $p1->sex;
echo $p1->age;
 
// 试图去打印私有的成员方法， 结果会发生错误
$p1->run();
?>
```

输出结果为：

```
Fatal error: Cannot access private property Person::$name
Fatal error: Cannot access private property Person::$sex
Fatal error: Cannot access private property Person::$age
Fatal error: Cannot access private property Person::$name
Fatal error: Call to private method Person::run() from context ' '
```

从上面的实例可以看到， 私有的成员是不能被外部访问的， 因为私有成员只能在本对象内部自己访问，比如，$p1这个对象自己想把他的私有属性说出去，在say\(\)这个方法里面访问了私有属性，这样是可以。

**没有加任何访问控制，默认的是public的，任何地方都可以访问**。

```php
// 这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法
function say() {
    echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
 
    // 在这里也可以访问私有方法
    //$this->run();
}
```

因为成员方法say\(\)是公有的， 所以我们在类的外部调用say\(\)方法是可以的，改变上面的代码：

```php
<?php
class Person {
    // 下面是人的成员属性
    private $name;  //人的名子,被private封装上了
    private $sex;   //人的性别, 被private封装上了
    private $age;   //人的年龄, 被private封装上了
 
    // 定义一个构造方法参数为私有的属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name, $sex, $age) {
        // 通过构造方法传进来的$name给私有成员属性$this->name赋初使值
        $this->name = $name;
 
        // 通过构造方法传进来的$sex给私有成员属性$this->sex赋初使值
        $this->sex = $sex;
 
        // 通过构造方法传进来的$age给私有成员属性$this->age赋初使值
        $this->age = $age;
    }
 
    // 这个人可以说话的方法, 说出自己的私有属性,在这里也可以访问私有方法
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
}
 
// 通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄
$p1 = new Person("张三", "男", 20);
$p2 = new Person("李四", "女", 30);
$p3 = new Person("王五", "男", 40);
 
// 下面访问$p1对象中的说话方法
$p1->say();
 
// 下面访问$p2对象中的说话方法
$p2->say();
 
// 下面访问$p3对象中的说话方法
$p3->say();
?>
```

输出结果为：

```
我的名子叫：张三 性别：男 我的年龄是：20我的名子叫：李四 性别：女 我的年龄是：30我的名子叫：王五 性别：男 我的年龄是：40
```

因为构造方法是默认的公有方法（构造方法不要设置成私有的），所以在类的外面可以访问到，这样就可以使用构造方法创建对象， 另外构造方法也是类里面的函数，所以可以用构造方法给私有的属性赋初值。Say\(\)的方法是默认公有的， 所以在外面也可以访问的到， 说出他自己的私有属性。

从上面的例子中我们可以看到， 私有的成员只能在类的内部使用， 不能被类外部直接来存取， 但是在类的内部是有权限访问的， 所以有时候我们需要在类的外面给私有属性赋值和读取出来，也就是给类的外部提供一些可以存取的接口，上例中构造方法就是一种赋值的形式， 但是构造方法只是在创建对象的时候赋值，如果我们已经有一个存在的对象了，想对这个存在的对象赋值， 这个时候，如果你还使用构造方法传值的形式传值， 那么就创建了一个新的对象，并不是这个已存在的对象了。所以我们要对私有的属性做一些可以被外部存取的接口，目的就是可以在对象存在的情况下，改变和存取 属性的值，但要注意，只有需要让外部改变的属性才这样做，不想让外面访问的属性是不做这样的接口的，这样就能达到封装的目的，所有的功能都是对象自己来完成，给外面提供尽量少的操作。

如果给类外部提供接口，可以为私有属性在类外部提供设置方法和获取方法，来操作私有属性。例如：

```php
private $age; // 私有的属性年龄
function setAge($age) { // 为外部提供一个公有设置年龄的方法
    if ($age < 0 || $age > 130) // 在给属性赋值的时候，为了避免非法值设置给属性
    return;
    $this->age = $age;
}
 
function getAge() { // 为外部提供一个公有获取年龄的方法
    return($this->age);
}
```

上面的方法是为一个成员属性设置和获取值， 当然你也可以为每个属性用同样的方法对其进行赋值和取值的操作，完成在类外部的存取工作。

