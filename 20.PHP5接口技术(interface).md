# 20.PHP5接口技术\(interface\)

PHP与大多数面向对象编程语言一样，不支持多重继承。也就是说每个类只能继承一个父类。为了解决这个问题，PHP引入了接口，接口的思想是指定了一个实现了该接口的类必须实现的一系列方法。**接口是一种特殊的抽象类，抽象类又是一种特殊的类，所以接口也是一种特殊的类，**为什么说接口是一种特殊的抽象类呢？如果一个抽象类里面的所有的方法都是抽象方法，那么我们就换一种声明方法使用“接口”；也就是说接口里面所有的方法必须都是声明为抽象方法，另外接口里面不能声明变量\(但可声明常量constant\)，而且接口里面所有的成员都是public权限的。所以子类在实现的时候也一定要使用public权限实限。

声明一个类的时候我们使用的关键字是“class”，而接口一种特殊的类，使用的关键字是“**interface**”;

```
类的定义：  class 类名{ … } ，
接口的声明：interface 接口名{ …}
```

```php
<?php
// 定义一个接口使用interface关键字，“One”为接口名称
interface One {
    // 定义一个常量
    const constant = 'constant value';
 
    // 定义了一个抽象方法”fun1”
    public function fun1();
 
    // 定义了抽象方法”fun2”
    public function fun2();
}
```

上例中定义了一个接口“one”，里面声明了两个抽象方法“fun1”和”fun2”，因为接口里面所有的方法都是抽象方法，所以在声明抽象方法的时候就不用像抽象类那样使用“abstract”这个关键字了，默认的已经加上这个关键字，另外在接口里边的”public”这个访问权限也可以去掉，因为默认就是public的，因为接口里所有成员都要是公有的，所在对于接口里面的成员我们就不能使用“private”的和“protected”的权限 了，都要用public或是默认的。另外在接口里面我们也声明了一个常量“constant“， 因为在接口里面不能用变量成员，所以我们要使用 const这个关键字声明。

因为接口是一种特殊的抽象类，里面所有的方法都是抽象方法，所以**接口也不能产生实例对象**; 它也做为一种规范，所有抽象方法需要子类去实现。

我们可以使用”**extends**”关键字让一个接口去继承另一个接口：

```php
<?php
// 使用”extends”继承另外一个接口
interface Two extends One {
    function fun3();
    function fun4();
}
```

而我们定义一接口的子类去实现接口中全部抽象方法使用的关键字是**“implements**”，而不是我们前面所说的“extends”;

```php
<?php
// 使用“implements”这个关键字去实现接口中的抽象方法 接口和类之间
class Three implements One {
    function fun1() {
        ...
    }
 
    function fun2() {
        ...
    }
}
 
// 实现了全部方法，我们去可以使用子类去实例化对象了
$three = new Three();
```

我们也可以使用抽象类，去实现接口中的部分抽象方法，但要想实例化对象，这个抽象类还要有子类把它所有的抽象方法都实现才行；

在前面我们说过，PHP是单继承的，一个类只能有一父类，但是一个类可以实现多个接口，就相当于一个类要遵守多个规范，就像我们不仅要遵守国家的法律，如果是在学校的话，还要遵守学校的校规一样；

```php
<?php
// 使用implements实现多个接口
class Four implemtns 接口一, 接口二, ... {
    // 必须把所有接口中的方法都要实现才可以实例化对象。
}
```

**PHP中不仅一个类可以实现多个接口，也可以在继承一个类的同时实现多个接口, 一定要先继承类再去实现接口；**

```php
<?php
// 使用extends继承一个类，使用implements实现多个接口
class Four extends 类名一 implemtns 接口一, 接口二, ... {
    // 所有接口中的方法都要实现才可以实例化对象
    ...
}
```



