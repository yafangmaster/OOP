# 15.static和const关键字的使用（self::）

static关键字是在类中描述**成员属性**和**成员方法**是静态的；静态的成员好处在哪里呢？前面我们声明了“Person”的人类，在“Person”这个类里如果我们加上一个“人所属国家”的属性，这样用“Person”这个类实例化出几百个或者更多个实例对象，每个对象里面就都有“所属国家”的属性了，如果开发的项目就是为中国人而开发的，那么每个对象里面就都有一个国家的属性是 “中国“其它的属性是不同的，如果我们把“国家”的属性做成静态的成员，这样国家的属性在内存中就只有一个，而让这几百个或更多的对象共用这一个属性，**static成员能够限制外部的访问，因为static的成员是属于类的，是不属于任何对象实例，是在类第一次被加载的时候分配的空间，其他类是无法访问的，只对类的实例共享，能一定程度对类该成员形成保护；**

从内存的角度我们来分析一下，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存“里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享，如下图：

![](http://images2015.cnblogs.com/blog/381128/201607/381128-20160717212916748-1685023709.png)

**类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。**

```php
<?php
class Person {
    // 下面是人的静态成员属性
    public static $myCountry = "中国";
 
    // var $name; //人的名子
 
    // 这是人的静态成员方法
    public static function say() {
        echo "我是中国人";
    }
}
 
// 输出静态属性
echo Person::$myCountry;
 
// 访问静态方法
Person::say();
 
// 重新给静态属性赋值
Person::$myCountry = "美国";
echo Person::$myCountry;
```

因为静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可以访问的到静态的成员；上面说过，**静态成员被这个类的每个实例对象所共享**，那么我们使用对象可不可以访问类中的静态成员呢？从上图中我们可以看到，静态的成员不是在每个对象内部存在的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，**使用对象访问不到静态成员的**，在其它的面向对象的语言中，比如Java是可以使用对象的方式访问静态成员的，如果PHP中可以使用对象访问静态成员的话，我们也尽量不要去使用，因为静态的成员我们在做项目的时候目的就是使用类名去访问。

**类里面的静态方法只能访问类的静态的属性**，在类里面的静态方法是不能访问类的非静态成员的，原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了**静态的方法是不用对象调用的，而是使用类名来访问**， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性，即然$this不存在，在静态方法中访其它静态成员我们使用的是一个特殊的类“self”; self和$this相似，**只不过self是代表这个静态方法所在的类**。所以在静态方法里，可以使用这个方法所在的类的“类名“，也可以使用“self”来访问其它静态成员，如果没有特殊情况的话，我们通常使用后者，即“**self::成员属性**”的方式。

```php
<?php
class Person {
    // 下面是人的静态成员属性
    public static $myCountry = "中国";
 
    // 这是人的静态成员方法， 通过self访问其它静态成员
    public static function say() {
        echo "我是" . self::$myCountry;
    }
}
 
// 访问静态方法
Person::say();
```

在非静态方法里可不可以访问静态成员呢，当然也是可以的了，但是也不能使用“$this”引用，也要使用类名或是”self::成员属性的形式”。

**const**是一个定义常量的关键字，在PHP中定义常量使用的是“**define\(\)**”这个函数，但是在类里面定义常量使用的是“const”这个关键字，类似于C中的\#define如果在程序中改变了它的值，那么会出现错误，**用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问**。

```php
<?php
class MyClass {
    // 定义一个常量constant
    const constant = 'constant value';
 
    function showConstant() {
        echo self::constant . " "; // 使用self访问，不要加“$”
    }
}
 
echo MyClass::constant . " "; // 使用类名来访问，也不加“$”
 
$class = new MyClass();
$class->showConstant();
// echo $class::constant; // 是不允许的
```



